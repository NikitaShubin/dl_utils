#!/bin/bash

# Циклически отображает содержание файла $file,
# содержание которого может меняться в результате
# выполнения других процессов.

# Если ни один аргумент не был задан, то выполяем для файла ./nohup.out:
if [ $# -eq 0 ]; then
    $0 ./nohup.out
    exit $?
fi

# Основные константы:
      secsm=$((   15))  # Пауза в секундах между обновлениями
  oldnessth=$(( 1000))  # Не отображать файлы старше этого срока в секундах
  num_lines=$((   15))  # Число последних строк файла, выводимых на экран
models_path=runs/detect/orion/weights  # Путь до сохраняемых моделей

bgb='\033[100m' # Начало серой полосы
egb='\033[0m'   # Конец  серой полосы
 up='\033[1A'   # На предыдущую строку

# Выводит серую полосу на всю длину строки терминала:
gb () {
    # максималная длина строки в консоли:
    termwidth="$(tput cols)"
    
    # Выводим серую полосу:
    echo -en "$bgb"
    for ((i=0; i<$termwidth; i++)); do
         echo -en ' '
    done
    echo -e "$egb"
}

# Повторяет заданную строку нужное число раз без перехода на новую строку:
repeat() {
    for ((i=0; i<$2; i++)); do
         echo -n "$1"
    done
}

# выводит заданное число пробелов:
spaces() {
    repeat " " "$1"
}

# Вывод строки с выравниванием по левому краю:
lalign() {
    # максималная длина строки в консоли:
    termwidth="$( tput cols )"
    
    # Обрезаем длину выводимой строки, если она выходит за пределы размера
    # line="$1"
    line=${1:0:$termwidth}
    
    # Длина полученной центрируемой строки:
    strwidth=${#line}
    
    # Выводим саму строку:
    echo -ne "$line"
    
    # Добиваем строку пробелами:
    spaces $(( termwidth - strwidth ))
}

# Вывод строки с выравниванием по правому краю:
ralign() {
    # максималная длина строки в консоли:
    termwidth="$( tput cols )"
    
    # Обрезаем длину выводимой строки, если она выходит за пределы размера
    # консоли:
    line=${1:0:$termwidth}
    
    # Длина полученной центрируемой строки:
    strwidth=${#line}
    
    # Выводим отступ нужной длины:
    spaces $(( termwidth - strwidth ))
    
    # Выводим саму строку:
    echo -ne "$line"
}

# Вывод строки с выравниванием по центру:
calign() {
    
    # максималная длина строки в консоли:
    termwidth="$( tput cols )"
    
    # Обрезаем длину выводимой строки, если она выходит за пределы размера
    # консоли:
    line=${1:0:$termwidth}
    
    # Длина полученной центрируемой строки:
    strwidth=${#line}
    
    # Определяем размер отступа:
    indentation=$(( (termwidth - strwidth) / 2 ))
    
    # Выводим отступ:
    spaces $indentation
    
    # Выводим саму строку:
    echo -ne "$line"
    
    # Добиваем строку пробелами:
    spaces $(( termwidth - indentation - ${#line} ))
}

# Бесконечный цикл вывода содержимого файлов:
while [ True ]; do
    clear
    
    # Пробегаем по переданным файлам, и распаршиваем маски, если надо:
    for file in `eval '{ echo "$@"; }'`; do
    # Такая странная конструкция с eval нужна как раз для распарсивания масок.

        # Пропускаем не существующий файл:
        if [ ! -f "$file" ]; then
            continue
        fi
        
        # Общее число строк в файле:
        total_num_lines=`cat "$file" | wc -l`
        
        # Число секунд, прошедшее с последнего обновления файла:
        oldness=$(( `date +%s` - `stat -c %Y "$file"` ))
        
        if [[ $oldnessth -gt 0 ]] && [[ $oldness -gt $oldnessth ]]; then
            continue
        fi
        
        # Выводим тослтую полосу с описанием:
        gb
        echo -en "$bgb"
        lalign "  Последние $num_lines из $total_num_lines строк файла \"$file\", обновлённый $oldness с. назад:  "
        gb
        
        # Выводим содержание последних строк файла:
        if true; then
            cat "$file" | tail -n $num_lines ; echo
        else
            cat "$file" | tail -n $num_lines | col -b
        fi
    done
    
    # Список сохранённых весов для YOLO, если есть:
    if [ -d "$models_path" ]; then
        
        # Выводим тослтую полосу с описанием:
        gb
        echo -en "$bgb"
        lalign "  Содержимое папки "$models_path" с весами моделей:  "
        gb
        
        # Выводим содержимое папки:
        ls -lahtr $models_path/*.pt | tail
    fi
    
    # Выводим тослтую полосу с обратным отсчётом до следующего обновления:
    gb; gb; gb
    echo -ne "$up$up"
    secs=$((secsm))
    while [ $secs -gt 0 ]; do
        echo -en "$bgb"
        calign "Вывод обновится через $secs с. ..."
        echo -ne "$egb\r"
        
        # Ещё одна секунда:
        sleep 1
        secs=$(($secs-1))
    done
    echo -ne "$egb"
done
